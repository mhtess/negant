---
title: "Understanding the model"
output: html_notebook
---


```{r}
library(rwebppl)
library(jsonlite)
library(ggthemes)
library(tidyverse)
library(knitr)
theme_set(theme_few())
```

```{r utils}
utils <- '
var round = function(x){
  return Math.round(x*100)/100
}

var isNegation = function(utt){
  return (utt.split("_")[0] == "not")
};

var hasNegModifier = function(utt){
  return (utt.split("_")[0] == "not")
};
var hasNegMorph = function(utt){
  return (utt.indexOf("un") > -1)
};
var roundTo3 = function(x){
  return Math.round(x * 1000) / 1000
}

var lowerBins = [
	0,
  0.01,
  0.05,
  0.1,
  0.15,
  0.2,
  0.25,
  0.3,
  0.35,
  0.4,
  0.45,
  0.5,
  0.55,
  0.6,
  0.65,
  0.7,
  0.75,
  0.8,
  0.85,
  0.9,
  0.95,
  0.99
];

var upperBins = [
  0.01,
  0.05,
  0.1,
  0.15,
  0.2,
  0.25,
  0.3,
  0.35,
  0.4,
  0.45,
  0.5,
  0.55,
  0.6,
  0.65,
  0.7,
  0.75,
  0.8,
  0.85,
  0.9,
  0.95,
  0.99,
  1
];

var midBins = map2(function(b1,b2){
  return roundTo3((b2 - b1)/2 + b1)
}, lowerBins, upperBins)

var thetaBins = map2(function(b1, b2){
  return roundTo3((b2-b1)/2 + b1);
}, midBins.slice(0, midBins.length-1), midBins.slice(1))

var avoidEnds = function(x){
  return x >= 1 ? 0.99 : x == 0 ? 0.01 : x
}

var lb = 0, ub = 1, diff = 0.05;
var bins = _.range(lb, ub + diff, diff)

var DiscreteGaussian = function(mu, sigma){
  Infer({model: function(){
    categorical({
      vs:bins,
      ps:map(function(x){Math.exp(Gaussian({mu, sigma}).score(x))}, bins)
    })
  }})
}

var DiscreteBeta = cache(function(a, b){
  Infer({model: function(){
    categorical({
      vs:midBins,
      ps:map(function(x){
        // var xi = x >= 1 ? 0.99 : x == 0 ? 0.01 : x
        Math.exp(Beta({a, b}).score(x))
      }, midBins)
    })
  }})
})
'
```


```{r meaningFn}
meaningFn <- '
var meaning = function(words, state, thresholds){
  return words == "happy" ? state > thresholds.happy :
  words == "not_happy" ? !(state > thresholds.happy) :
  words == "unhappy" ? state < thresholds.unhappy :
  words == "not_unhappy" ? !(state < thresholds.unhappy) :
  words == "sad" ? state < thresholds.sad :
  words == "not_sad" ? !(state < thresholds.sad) :
  words == "neither_nor" ? (
    !(state > thresholds.happy) &&
    !(state < thresholds.unhappy)
  ) :
  true
};
'
```

# Separate thresholds RSA


```{r rsa-separateThresholds}
rsa <- '
var utterances = [
  "happy",
  "not_unhappy",
  "not_happy",
  "unhappy",
  // "neither_nor"
];

var individualCosts = {
  happy: 0,
  unhappy: 0.5,
  not_happy: 1,
  not_unhappy: 1.5
}

var cost_yes = 0;
var cost_neg = 3;

var uttCosts = map(function(u) {
  return isNegation(u) ? Math.exp(-cost_neg) : Math.exp(-cost_yes)
  // return Math.exp(-individualCosts[u])
}, utterances)

var utterancePrior = Infer({model: function(){
  return utterances[discrete(uttCosts)]
}});


var speakerOptimality = 1;
var speakerOptimality2 = 1;

var listener0 = cache(function(utterance, thresholds) {
  Infer({model: function(){
    var state = sample(DiscreteBeta(1, 1));
    // var state = sample(DiscreteGaussian(0, 0.5));
    var m = meaning(utterance, state, thresholds);
    condition(m);
    return state;
  }})
}, 10000);

var speaker1 = cache(function(state, thresholds) {
  Infer({model: function(){
    var utterance = sample(utterancePrior);
    var L0 = listener0(utterance, thresholds);
    factor(speakerOptimality*L0.score(state));
    return utterance;
  }})
}, 10000);

var greaterThanThresholdBins = _.range(lb, ub, diff)
var lessThanThresholdBins = _.range(lb+diff, ub+diff, diff)

var listener1 = cache(function(utterance) {
  Infer({model: function(){
    var thresholds = {
      happy: uniformDraw(greaterThanThresholdBins),
      unhappy: uniformDraw(lessThanThresholdBins)
    }

    var state = sample(DiscreteBeta(1, 1));
    // var state = sample(DiscreteGaussian(0, 0.5));

    var S1 = speaker1(state, thresholds)
    observe(S1, utterance)
    return state
  }})
}, 10000);
'
```


```{r wpplCalls}
listenerCall <- '
_.fromPairs(map(function(u){
  var post = listener1(u)
  return [u, post]
}, utterances))
'

speakerCall <- '
_.flatten(_.flatten(
map(function(tH){
  map(function(tU){
    map(function(s){
      var speakProbs = speaker1(s, {happy: tH, unhappy: tU})
       return {  
          state: s,
          happy_theta:tH, 
          unhappy_theta:tU, 
          "happy": Math.exp(speakProbs.score("happy")),
          "unhappy": Math.exp(speakProbs.score("unhappy")),
          "not_unhappy": Math.exp(speakProbs.score("not_unhappy")),
          "not_happy": Math.exp(speakProbs.score("not_happy"))
        }
    }, bins)
//   }, [0.5])
  }, lessThanThresholdBins)
}, greaterThanThresholdBins)
))
'
```

```{r runSpeaker}
rs.wp <- webppl(paste(utils, meaningFn, rsa, speakerCall,  sep = '\n'))

rs.tidy <- data.frame(rs.wp) %>%
  gather(utt, prob, -state, -happy_theta, -unhappy_theta)
```


Faceting by thresholds
```{r facet-threshold}
ggplot(rs.tidy, aes( x = state, y = prob, color = utt))+
  geom_line()+#aes(frame = happy_theta))+
  scale_color_solarized()+
  facet_grid(unhappy_theta~happy_theta)+
  scale_x_continuous(breaks = c(0, 0.5, 1))+
  scale_y_continuous(breaks = c(0, 0.5, 1))

#ggsave("figs/S1_uttXstateXthetas_wCost.pdf", width = 20, height = 14)
```

with fixed unhappy_theta

```{r}
fig.theta.marg <- rs.tidy %>%
      mutate(utt = factor(utt,
                            levels = c("unhappy",
                                       "not_happy",
                                       "not_unhappy",
                                       "happy"))) %>%
  ggplot(., aes( x = state, y = prob, color = utt))+
  geom_line(aes(frame = happy_theta), size = 2)+
  scale_color_solarized()+
  scale_x_continuous(breaks = c(0, 0.5, 1))+
  scale_y_continuous(breaks = c(0, 0.5, 1))+
  ggtitle("unhappy = x < 0.5; happy threshold = ")+
  ylab("Speaker production probability")+
  xlab("Degree of happiness")+
  theme(text = element_text(size = 16))

gganimate(fig.theta.marg,
          "figs/S1_unhappyTheta0.5.gif")

#ggsave("figs/S1_uttXstateXthetas_wCost.pdf", width = 20, height = 14)
```



Marginalizing out thresholds

```{r marginalize.thresholds}
rs.marginal <- rs.tidy %>%
  group_by(state, utt) %>%
  summarize(marginalProb = mean(prob)) %>%
        mutate(utt = factor(utt,
                            levels = c("unhappy",
                                       "not_happy",
                                       "not_unhappy",
                                       "happy")))


ggplot(rs.marginal, aes( x = state, y = marginalProb, color = utt))+
  geom_line(size = 1.2)+
  scale_color_solarized()+
  xlab("Degree of happiness")+
  ylab("Speaker utterance production probability")+
  scale_x_continuous(breaks =c(0, 1))+
  scale_y_continuous(breaks = c(0, 0.5))

ggsave("figs/S1_uttMarginals_wCost3_alpha1.png", width = 6, height = 3.7)
```

"Not Unhappy" is semantically equivalent to "happy". The higher the state, the more likely "happy" (and "not unhappy") is to be produced by a speaker (because it's more likely to be true, given the uniform priors on thresholdse). 

In the midpoint, "happy" / "not unhappy" is less true, and "unhappy"/ "not happy" is more true. 

```{r runListener}
rs.listener.wp <- webppl(paste(utils, meaningFn, rsa, listenerCall,  sep = '\n'))

rs.listener.wp.tidy <- bind_rows(
  data.frame(rs.listener.wp$happy) %>% 
    mutate(utterance = "happy"),
  data.frame(rs.listener.wp$unhappy) %>% 
    mutate(utterance = "unhappy"),
  data.frame(rs.listener.wp$not_unhappy) %>% 
    mutate(utterance = "not_unhappy"),
  data.frame(rs.listener.wp$not_happy) %>% 
    mutate(utterance = "not_happy")
)


rs.listener.wp.tidy.samples <- get_samples(
  rs.listener.wp.tidy %>% rename(prob = probs), 10000) %>%
    mutate(utterance = factor(utterance,
                            levels = c("unhappy",
                                       "not_happy",
                                       "not_unhappy",
                                       "happy")))

ggplot(rs.listener.wp.tidy.samples, 
       aes( x = support,fill = utterance, color = utterance))+
  geom_density(alpha = 0.4, size = 1.3)+
  scale_fill_solarized()+
  scale_color_solarized()+
  xlab("Degree of happiness")+
  ylab("Posterior probability density")+
  scale_x_continuous(breaks =c(0, 1))+
  scale_y_continuous(breaks = c(0, 2))

ggsave("figs/L1_posteriors_wCost3_alpha1.png", width = 6, height = 4)
```


```{r}
rs.listener.wp.tidy %>%
  group_by(utterance) %>%
  summarize(interpretation = sum(probs * support)) %>%
    mutate(utterance = factor(utterance,
                            levels = c("unhappy",
                                       "not_happy",
                                       "not_unhappy",
                                       "happy"))) %>%
  ggplot(., aes( x = utterance, y=interpretation,
                 fill = utterance, color = utterance))+
    geom_col(position = position_dodge(0.8), 
             width = 0.8,
             alpha =0.8, color = 'black')+
    #coord_flip()+
  geom_hline(yintercept = 0.5, lty = 3)+
  scale_fill_solarized()+
  guides(fill = F)+
  scale_y_continuous(limits = c(0, 1), breaks = c(0, 0.5, 1))+
  xlab("")+
  theme(axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1))

ggsave("figs/L1_means_wCost3_alpha1.png", width = 4, height = 3.5)
```

```{r}
rs.listener.wp.tidy %>%
  group_by(utterance) %>%
  summarize(interpretation = sum(probs * support)) %>%
  kable()
```



# Uncertain "has threshold" RSA

```{r rsa-uncertainHasThresholds}
uncertainHasThresholdsRSA <- '
var utterances = [
  "happy",
  "not_unhappy",
  "not_happy",
  "unhappy",
  // "neither_nor"
];

var cost_yes = 0;
var cost_not = 3;
var cost_un = 3;

var uttCosts = map(function(u) {
  var notCost = hasNegModifier(u) ? cost_not : 0
  var unCost = hasNegMorph(u) ? cost_un : 0
  var totalCost = notCost + unCost
  return Math.exp(-totalCost)
}, utterances)

var utterancePrior = Infer({model: function(){
  return utterances[discrete(uttCosts)]
}});

var speakerOptimality = 1;
var speakerOptimality2 = 1;

var has_an_unhappy_threshold_prior = 0.2;

var listener0 = cache(function(utterance, thresholds) {
  Infer({model: function(){
    var state = sample(DiscreteBeta(1, 1));
    // var state = sample(DiscreteGaussian(0, 0.5));
    var m = meaning(utterance, state, thresholds);
    condition(m);
    return state;
  }})
}, 10000);

var speaker1 = cache(function(state, thresholds) {
  Infer({model: function(){
    var utterance = sample(utterancePrior);
    var L0 = listener0(utterance, thresholds);
    factor(speakerOptimality*L0.score(state));
    return utterance;
  }})
}, 10000);

var listener1 = cache(function(utterance) {
  Infer({model: function(){

    var happy_threshold = uniformDraw(thetaBins)
    var has_an_unhappy_threshold = flip(has_an_unhappy_threshold_prior)
    var unhappy_threshold = has_an_unhappy_threshold ?
      uniformDraw(thetaBins) :
      happy_threshold

    var thresholds = {
      happy: happy_threshold,
      unhappy: unhappy_threshold
    }

    var state = sample(DiscreteBeta(1, 1));
    // var state = sample(DiscreteGaussian(0, 0.5));

    var S1 = speaker1(state, thresholds)
    observe(S1, utterance)
    return state
  }})
}, 10000);
'
```

```{r wpplCalls-uncertainHasThresholds}
uncertainHasThresholdListenerCall <- '
_.fromPairs(map(function(u){
  var post = listener1(u)
  return [u, post]
}, utterances))
'
```

```{r runUncertainHasThresholdListener}
rs.listener.wp.2 <- webppl(paste(utils, meaningFn, uncertainHasThresholdsRSA, uncertainHasThresholdListenerCall,  sep = '\n'))

rs.listener.wp.tidy.2 <- bind_rows(
  data.frame(rs.listener.wp.2$happy) %>% 
    mutate(utterance = "happy"),
  data.frame(rs.listener.wp.2$unhappy) %>% 
    mutate(utterance = "unhappy"),
  data.frame(rs.listener.wp.2$not_unhappy) %>% 
    mutate(utterance = "not_unhappy"),
  data.frame(rs.listener.wp.2$not_happy) %>% 
    mutate(utterance = "not_happy")
)


rs.listener.wp.tidy.samples.2 <- get_samples(
  rs.listener.wp.tidy.2 %>% rename(prob = probs), 10000) %>%
    mutate(utterance = factor(utterance,
                            levels = c("unhappy",
                                       "not_happy",
                                       "not_unhappy",
                                       "happy")))

ggplot(rs.listener.wp.tidy.samples.2, 
       aes( x = support,fill = utterance, color = utterance))+
  geom_density(alpha = 0.4, size = 1.3)+
  scale_fill_solarized()+
  scale_color_solarized()+
  xlab("Degree of happiness")+
  ylab("Posterior probability density")+
  scale_x_continuous(breaks =c(0, 1))+
  scale_y_continuous(breaks = c(0, 2))

#ggsave("figs/L1_posteriors_wCost3_alpha1.png", width = 6, height = 4)
```

# Uncertain alternatives RSA

```{r rsa-uncertainAlternatives}
uncertainAlternativesRSA <- '
// var utterances = [
//  "happy",
//  "not_unhappy",
//  "not_happy",
//  "unhappy",
  // "neither_nor"
// ];

var sets_of_alternatives = [
  ["happy", "sad", "not_happy", "not_sad"],
  ["happy", "unhappy", "not_unhappy"],
  ["happy", "unhappy", "not_happy", "not_unhappy"]
]


var getThresholds = function(utterances){
  var positiveForms = filter(function(u){
    return !(hasNegModifier(u))
  }, utterances)
  return _.fromPairs(map(function(u){
    return [u, uniformDraw(thetaBins)]
  }, positiveForms))
}

var cost_yes = 0;
var cost_not = 2;
var cost_un = 5;


var uttCosts = function(utterances){
  return map(function(u) {
    var notCost = hasNegModifier(u) ? cost_not : 0
    var unCost = hasNegMorph(u) ? cost_un : 0
    var totalCost = notCost + unCost
    return Math.exp(-totalCost)
  }, utterances)
}

var getUtterancePrior = cache(function(utterances){
  var uttProbs = uttCosts(utterances);
  return Categorical({vs: utterances, ps: uttProbs})
})

var speakerOptimality = 1;

var listener0 = cache(function(utterance, thresholds) {
  Infer({model: function(){
    var state = sample(DiscreteBeta(1, 1));
    // var state = sample(DiscreteGaussian(0, 0.5));
    var m = meaning(utterance, state, thresholds);
    condition(m);
    return state;
  }})
}, 10000);

var speaker1 = cache(function(state, thresholds, alternatives) {
  Infer({model: function(){
    var utterancePrior = getUtterancePrior(alternatives);
    var utterance = sample(utterancePrior);
    var L0 = listener0(utterance, thresholds);
    factor(speakerOptimality*L0.score(state));
    return utterance;
  }})
}, 10000);

var listener1 = cache(function(utterance) {
  Infer({model: function(){

    // var speakerAlternatives = uniformDraw(sets_of_alternatives)
  // var speakerAlternatives = categorical({vs: sets_of_alternatives, ps:[0,0,1]})
  var speakerAlternatives = ["happy", "unhappy", "not_happy", "not_unhappy"]
  // console.log(speakerAlternatives)
    var thresholds = getThresholds(speakerAlternatives)
    //console.log(JSON.stringify(thresholds))
    var state = sample(DiscreteBeta(1, 1));
    // var state = sample(DiscreteGaussian(0, 0.5));

    var S1 = speaker1(state, thresholds, speakerAlternatives)
    observe(S1, utterance)
    return state
  }})
}, 10000);
'
```

```{r wpplCalls-uncertainAlternatives}
uncertainAlternativesListenerCall <- '
_.fromPairs(map(function(u){
  var post = listener1(u)
  return [u, post]
}, ["happy", "unhappy", "not_unhappy", "not_happy"]))
'
#uncertainAlternativesListenerCall <- 'listener1("not_happy")'
```

```{r runUncertainAlternativesListener}
rs.listener.wp.2 <- webppl(paste(utils, meaningFn, uncertainAlternativesRSA, uncertainAlternativesListenerCall,  sep = '\n'))

rs.listener.wp.tidy.2 <- bind_rows(
  data.frame(rs.listener.wp.2$happy) %>% 
    mutate(utterance = "happy"),
  data.frame(rs.listener.wp.2$unhappy) %>% 
    mutate(utterance = "unhappy"),
  data.frame(rs.listener.wp.2$not_unhappy) %>% 
    mutate(utterance = "not_unhappy"),
  data.frame(rs.listener.wp.2$not_happy) %>% 
    mutate(utterance = "not_happy")
)


rs.listener.wp.tidy.samples.2 <- get_samples(
  rs.listener.wp.tidy.2 %>% rename(prob = probs), 10000) %>%
    mutate(utterance = factor(utterance,
                            levels = c("unhappy",
                                       "not_happy",
                                       "not_unhappy",
                                       "happy")))

ggplot(rs.listener.wp.tidy.samples.2, 
       aes( x = support,fill = utterance, color = utterance))+
  geom_density(alpha = 0.4, size = 1.3)+
  scale_fill_solarized()+
  scale_color_solarized()+
  xlab("Degree of happiness")+
  ylab("Posterior probability density")+
  scale_x_continuous(breaks =c(0, 1))+
  scale_y_continuous(breaks = c(0, 2))

#ggsave("figs/L1_posteriors_wCost3_alpha1.png", width = 6, height = 4)
#head(rs.listener.wp.2)
```


```{r}
rs.listener.wp.tidy.2 %>%
  group_by(utterance) %>%
  summarize(interpretation = sum(probs * support)) %>%
    mutate(utterance = factor(utterance,
                            levels = c("unhappy",
                                       "not_happy",
                                       "not_unhappy",
                                       "happy"))) %>%
  ggplot(., aes( x = utterance, y=interpretation,
                 fill = utterance, color = utterance))+
    geom_col(position = position_dodge(0.8), 
             width = 0.8,
             alpha =0.8, color = 'black')+
    #coord_flip()+
  geom_hline(yintercept = 0.5, lty = 3)+
  scale_fill_solarized()+
  guides(fill = F)+
  scale_y_continuous(limits = c(0, 1), breaks = c(0, 0.5, 1))+
  xlab("")+
  theme(axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1))

#ggsave("figs/L1_means_wCost3_alpha1.png", width = 4, height = 3.5)
```
```{r}
rs.listener.wp.tidy.2 %>%
  group_by(utterance) %>%
  summarize(interpretation = sum(probs * support)) %>%
  kable()
```


## Parameter exploration

Fixed alternatives model: 
- cost to "un": makes "unhappy more extreme"